import { useState, useEffect, useCallback } from "react";
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

// --- 1. LOCAL STORAGE UTILITIES ---
const getInitialScores = () => {
  const savedScores = localStorage.getItem("zanpicTttScores");
  try {
    if (savedScores) return JSON.parse(savedScores);
  } catch (e) {
    console.error("Could not parse saved scores:", e);
  }
  return { X: 0, O: 0, Draw: 0 };
};

const getInitialBoard = () => {
  const savedBoard = localStorage.getItem("zanpicTttBoard");
  try {
    if (savedBoard) return JSON.parse(savedBoard);
  } catch (e) {
    console.error("Could not parse saved board:", e);
  }
  return Array(9).fill(null);
};

const getInitialState = () => {
  const savedState = localStorage.getItem("zanpicTttState");
  try {
    if (savedState) return JSON.parse(savedState);
  } catch (e) {
    console.error("Could not parse saved state:", e);
  }
  return { isXNext: true, winner: null };
};

// --- 2. MINIMAX CORE LOGIC ---
const scoreCheck = (b) => {
  const lines = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8],
    [0, 3, 6], [1, 4, 7], [2, 5, 8],
    [0, 4, 8], [2, 4, 6]
  ];
  for (let [a, b2, c] of lines) {
    if (b[a] && b[a] === b[b2] && b[a] === b[c]) return b[a];
  }
  return null;
};

const minimax = (currentBoard, depth, isMaximizing) => {
  const result = scoreCheck(currentBoard);
  const isFull = currentBoard.every(cell => cell !== null);
  if (result === "O") return 10 - depth;
  if (result === "X") return depth - 10;
  if (isFull) return 0;

  if (isMaximizing) {
    let bestScore = -Infinity;
    for (let i = 0; i < 9; i++) {
      if (currentBoard[i] === null) {
        currentBoard[i] = "O";
        let score = minimax(currentBoard, depth + 1, false);
        currentBoard[i] = null;
        bestScore = Math.max(score, bestScore);
      }
    }
    return bestScore;
  } else {
    let bestScore = Infinity;
    for (let i = 0; i < 9; i++) {
      if (currentBoard[i] === null) {
        currentBoard[i] = "X";
        let score = minimax(currentBoard, depth + 1, true);
        currentBoard[i] = null;
        bestScore = Math.min(score, bestScore);
      }
    }
    return bestScore;
  }
};

// --- 3. COMPONENT ---
export default function ZanpicTicTacToe() {
  const emptyBoard = Array(9).fill(null);

  const [board, setBoard] = useState(getInitialBoard);
  const [scores, setScores] = useState(getInitialScores);
  const initialState = getInitialState();
  const [isXNext, setIsXNext] = useState(initialState.isXNext);
  const [winner, setWinner] = useState(initialState.winner);

  // Save scores
  useEffect(() => {
    localStorage.setItem("zanpicTttScores", JSON.stringify(scores));
  }, [scores]);

  // Save board
  useEffect(() => {
    localStorage.setItem("zanpicTttBoard", JSON.stringify(board));
  }, [board]);

  // Save turn + winner
  useEffect(() => {
    localStorage.setItem("zanpicTttState", JSON.stringify({ isXNext, winner }));
  }, [isXNext, winner]);

  const checkWinner = useCallback((b) => scoreCheck(b), []);

  const handleClick = useCallback((i) => {
    if (board[i] || winner || !isXNext) return;
    const newBoard = [...board];
    newBoard[i] = "X";
    const win = checkWinner(newBoard);

    setBoard(newBoard);
    if (win) {
      setWinner(win);
      setScores(prev => ({ ...prev, [win]: prev[win] + 1 }));
    } else if (newBoard.every(cell => cell !== null)) {
      setWinner("Draw");
      setScores(prev => ({ ...prev, Draw: prev.Draw + 1 }));
    }
    if (!win && !newBoard.every(cell => cell !== null)) {
      setIsXNext(false);
    }
  }, [board, isXNext, winner, checkWinner]);

  const findBestMove = useCallback(() => {
    let bestScore = -Infinity;
    let move = -1;
    let currentBoard = [...board];
    for (let i = 0; i < 9; i++) {
      if (currentBoard[i] === null) {
        currentBoard[i] = "O";
        let score = minimax(currentBoard, 0, false);
        currentBoard[i] = null;
        if (score > bestScore) {
          bestScore = score;
          move = i;
        }
      }
    }
    return move;
  }, [board]);

  const makeAIMove = useCallback(() => {
    const moveIndex = findBestMove();
    if (moveIndex !== -1) {
      setBoard(prevBoard => {
        const newBoard = [...prevBoard];
        newBoard[moveIndex] = "O";
        const win = checkWinner(newBoard);
        if (win) {
          setWinner(win);
          setScores(prev => ({ ...prev, [win]: prev[win] + 1 }));
        } else if (newBoard.every(cell => cell !== null)) {
          setWinner("Draw");
          setScores(prev => ({ ...prev, Draw: prev.Draw + 1 }));
        }
        if (!win && !newBoard.every(cell => cell !== null)) {
          setIsXNext(true);
        }
        return newBoard;
      });
    }
  }, [findBestMove, checkWinner]);

  useEffect(() => {
    if (!isXNext && !winner) {
      const timeout = setTimeout(() => makeAIMove(), 500);
      return () => clearTimeout(timeout);
    }
  }, [isXNext, winner, makeAIMove]);

  const reset = () => {
    setBoard(emptyBoard);
    setWinner(null);
    setIsXNext(true);
  };

  const resetScores = () => {
    setScores({ X: 0, O: 0, Draw: 0 });
    reset();
  };

  return (
    <div className="flex flex-col items-center p-6 bg-gray-50 min-h-screen">
      <motion.h1
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-4xl font-bold mb-6 text-gray-800"
      >
        Zanpic Tic Tac Toe (vs. Unbeatable AI)
      </motion.h1>

      {/* Scoreboard */}
      <div className="flex justify-center w-full max-w-sm mb-6 p-3 bg-indigo-100 rounded-lg shadow-inner text-lg font-bold text-gray-800">
        <span className="mx-4">ğŸ‘¤ X Wins: {scores.X}</span>
        <span className="mx-4">ğŸ¤– O Wins: {scores.O}</span>
        <span className="mx-4">ğŸ¤ Draws: {scores.Draw}</span>
      </div>

      <Card className="p-6 shadow-xl rounded-2xl bg-white">
        <CardContent>
          <div className="grid grid-cols-3 gap-3">
            {board.map((cell, i) => (
              <motion.button
                whileTap={{ scale: 0.9 }}
                key={i}
                onClick={() => handleClick(i)}
                className="w-20 h-20 flex items-center justify-center text-3xl font-bold rounded-xl shadow-md transition-colors"
                style={{
                  backgroundColor:
                    cell === "X"
                      ? "#E1F5FE"
                      : cell === "O"
                      ? "#FFEBEE"
                      : winner
                      ? "#F5F5F5"
                      : "#E0E0E0",
                  color:
                    cell === "X"
                      ? "#0277BD"
                      : cell === "O"
                      ? "#D32F2F"
                      : "#424242"
                }}
                disabled={!!winner || !!cell || !isXNext}
              >
                {cell}
              </motion.button>
            ))}
          </div>

          <div className="text-center mt-4 text-xl font-semibold text-gray-700 h-8">
            {winner === "Draw"
              ? "ğŸ˜¾ Game Over: It's a Draw!"